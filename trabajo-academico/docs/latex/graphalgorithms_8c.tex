\hypertarget{graphalgorithms_8c}{}\section{Referencia del Archivo graphalgorithms.\+c}
\label{graphalgorithms_8c}\index{graphalgorithms.\+c@{graphalgorithms.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include $<$stdbool.\+h$>$}\newline
{\ttfamily \#include $<$float.\+h$>$}\newline
{\ttfamily \#include $<$limits.\+h$>$}\newline
{\ttfamily \#include $<$omp.\+h$>$}\newline
{\ttfamily \#include \char`\"{}graph.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}graphalgorithms.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}queue.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}priority\+\_\+queue.\+h\char`\"{}}\newline
\subsection*{defines}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{graphalgorithms_8c_a2a37b4217917105aac7557862ccc19c3}\label{graphalgorithms_8c_a2a37b4217917105aac7557862ccc19c3}} 
\#define {\bfseries M\+A\+X\+S\+I\+ZE}~1420000
\item 
\mbox{\Hypertarget{graphalgorithms_8c_a7858acc99855a4aac8d78bf22f709b1f}\label{graphalgorithms_8c_a7858acc99855a4aac8d78bf22f709b1f}} 
\#define {\bfseries M\+A\+X\+E\+D\+G\+ES}~21231801
\end{DoxyCompactItemize}
\subsection*{Funciones}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{graphalgorithms_8c_af2b71e81e0cc7b18eb494b9bfc3f79c1}{get\+Degree\+Erdos} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int $\ast$top)
\item 
void \hyperlink{graphalgorithms_8c_a5a6317bae022cc2eb66e96d05b5981e1}{compute\+Degree\+Metric} (\hyperlink{structgraph}{T\+Graph} $\ast$g)
\item 
void \hyperlink{graphalgorithms_8c_a88661d3bcfaf2251248897b52deb6478}{get\+Page\+Rank\+Erdos} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int $\ast$top)
\item 
void \hyperlink{graphalgorithms_8c_a322c6ba75c59c6c7e5c45c809e81bb24}{get\+Closeness\+Erdos} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int $\ast$top)
\item 
void \hyperlink{graphalgorithms_8c_a58dc3553c3af88c5f7e1e6879e958341}{graph\+Initialize\+Page\+Rank} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int option)
\item 
void \hyperlink{graphalgorithms_8c_aa7498f384b25e2fa68ca828a58427c36}{compute\+Page\+Rank\+Metric\+Iterative} (\hyperlink{structgraph}{T\+Graph} $\ast$g, double alpha, int ini\+Option, int iterations)
\item 
int \hyperlink{graphalgorithms_8c_a9a0405fae235e46f2e982637e22a88d8}{compute\+Page\+Rank\+Metric\+Epsilon} (\hyperlink{structgraph}{T\+Graph} $\ast$g, double alpha, int ini\+Option, int max\+Iterations, double eps)
\item 
double \hyperlink{graphalgorithms_8c_ac283fa06f9ce14ebbbbdc44c6dabe38d}{compute\+Page\+Rank\+Metric\+Vertex} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int uindex, double alpha)
\item 
\mbox{\Hypertarget{graphalgorithms_8c_a9cbf4918872eef25466158719705a2f0}\label{graphalgorithms_8c_a9cbf4918872eef25466158719705a2f0}} 
void {\bfseries dijkstra} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int root, double $\ast$dist, \hyperlink{struct_p_q}{T\+Priority\+Queue} $\ast$pq)
\item 
void \hyperlink{graphalgorithms_8c_ab86714914e03247237599628e08a7439}{compute\+Closeness\+Metric} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int type)
\item 
double \hyperlink{graphalgorithms_8c_ad015854cbdc65837f2a5422682f0d3e9}{compute\+Closeness\+Metric\+Vertex} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int uindex, double $\ast$dist, \hyperlink{struct_p_q}{T\+Priority\+Queue} $\ast$pq, int type)
\item 
int \hyperlink{graphalgorithms_8c_a522d4e813d433f1fec5ab33a8a8913a0}{graph\+Is\+Disconnected} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int ref)
\item 
void \hyperlink{graphalgorithms_8c_ac5f3adaf46274b9d474329660f241f06}{B\+FS} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int root, int $\ast$dist)
\item 
void \hyperlink{graphalgorithms_8c_a74f357c09771e6c19c0e521007dd804b}{compute\+Closeness\+MetricP} (\hyperlink{structgraph}{T\+Graph} $\ast$g, int type, int nthreads)
\end{DoxyCompactItemize}


\subsection{Documentación de las funciones}
\mbox{\Hypertarget{graphalgorithms_8c_ac5f3adaf46274b9d474329660f241f06}\label{graphalgorithms_8c_ac5f3adaf46274b9d474329660f241f06}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!B\+FS@{B\+FS}}
\index{B\+FS@{B\+FS}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{B\+F\+S()}{BFS()}}
{\footnotesize\ttfamily void B\+FS (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int}]{root,  }\item[{int $\ast$}]{dist }\end{DoxyParamCaption})}

Recorre el grafo a partir de una raíz para encontrar las distancias. 

Definición en la línea 335 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
335                                          \{
336     \textcolor{keywordtype}{int} i, j;
337     \textcolor{keywordflow}{for} (i = 0; i < g->size; ++i) dist[i] = INT\_MAX;
338     dist[root] = 0;
339     \hyperlink{structqueue}{TQueue} q;
340     queueInitialize(&q);
341     queueInsert(&q, root);
342     \textcolor{keywordflow}{while} (!queueIsEmpty(&q)) \{
343         i = queuePop(&q);
344         \hyperlink{structedge}{TEdge}* e = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i)->first;
345         \textcolor{keywordflow}{while} (e != NULL) \{
346             j = e->index;
347             \textcolor{keywordflow}{if} (dist[j] == INT\_MAX) \{
348                 dist[j] = dist[i] + 1;
349                 queueInsert(&q, j);
350             \}
351             e = e->next;
352         \}
353     \}
354     queueClean(&q);
355     \textcolor{keywordflow}{return};
356 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_ab86714914e03247237599628e08a7439}\label{graphalgorithms_8c_ab86714914e03247237599628e08a7439}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!compute\+Closeness\+Metric@{compute\+Closeness\+Metric}}
\index{compute\+Closeness\+Metric@{compute\+Closeness\+Metric}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{compute\+Closeness\+Metric()}{computeClosenessMetric()}}
{\footnotesize\ttfamily void compute\+Closeness\+Metric (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int}]{type }\end{DoxyParamCaption})}

Computa la métrica de cercanía para todos los vértices. 

Definición en la línea 251 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
251                                                  \{
252     \textcolor{keywordtype}{int} i;
253     \hyperlink{structvertex}{TVertex}* v;
254     \textcolor{keywordtype}{double}* dist = malloc(g->size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}));
255     \hyperlink{struct_p_q}{TPriorityQueue} pq;
256     pqInitialize(&pq, MAXEDGES);
257     \textcolor{keywordflow}{for} (i = 0; i < g->size; ++i) \{
258         v = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i);
259         v->closeness = \hyperlink{graphalgorithms_8c_ad015854cbdc65837f2a5422682f0d3e9}{computeClosenessMetricVertex}(g, i, dist, &pq, type);
260         \textcolor{comment}{/*printf("%d: %.16lf\(\backslash\)n", i, v->closeness);*/}
261     \}
262     free(dist);
263     pqClean(&pq);
264     \textcolor{keywordflow}{return};
265 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_a74f357c09771e6c19c0e521007dd804b}\label{graphalgorithms_8c_a74f357c09771e6c19c0e521007dd804b}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!compute\+Closeness\+MetricP@{compute\+Closeness\+MetricP}}
\index{compute\+Closeness\+MetricP@{compute\+Closeness\+MetricP}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{compute\+Closeness\+Metric\+P()}{computeClosenessMetricP()}}
{\footnotesize\ttfamily void compute\+Closeness\+MetricP (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int}]{type,  }\item[{int}]{nthreads }\end{DoxyParamCaption})}

Computa la métrica de cercanía usando Open\+MP (en paralelo). 

Definición en la línea 361 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
361                                                                 \{
362     \textcolor{keywordtype}{int} i;
363     \hyperlink{structvertex}{TVertex}* v;
364     \textcolor{keywordtype}{double}* dist;
365     \hyperlink{struct_p_q}{TPriorityQueue} pq;
366 \textcolor{preprocessor}{    #pragma omp parallel num\_threads(nthreads) private(i, pq, dist, v)}
367     \{
368         dist = malloc(g->size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}));
369         pqInitialize(&pq, MAXEDGES);
370 \textcolor{preprocessor}{        #pragma omp for schedule(static, 10)}
371         \textcolor{keywordflow}{for} (i = 0; i < g->size; ++i) \{
372             \textcolor{keywordflow}{if} (pq.heap == NULL || dist == NULL) \hyperlink{graph_8c_a7f5e83144dce23e0e8f1291dfc73cea0}{reportError}(\textcolor{stringliteral}{"Memory"});
373             v = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i);
374             v->closeness = \hyperlink{graphalgorithms_8c_ad015854cbdc65837f2a5422682f0d3e9}{computeClosenessMetricVertex}(g, i, dist, &pq, type);
375             \textcolor{comment}{/*printf("%d: %.16lf\(\backslash\)n", i, v->closeness);*/}
376         \}
377         free(dist);
378         pqClean(&pq);
379     \}
380     \textcolor{keywordflow}{return};
381 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_ad015854cbdc65837f2a5422682f0d3e9}\label{graphalgorithms_8c_ad015854cbdc65837f2a5422682f0d3e9}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!compute\+Closeness\+Metric\+Vertex@{compute\+Closeness\+Metric\+Vertex}}
\index{compute\+Closeness\+Metric\+Vertex@{compute\+Closeness\+Metric\+Vertex}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{compute\+Closeness\+Metric\+Vertex()}{computeClosenessMetricVertex()}}
{\footnotesize\ttfamily double compute\+Closeness\+Metric\+Vertex (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int}]{uindex,  }\item[{double $\ast$}]{dist,  }\item[{\hyperlink{struct_p_q}{T\+Priority\+Queue} $\ast$}]{pq,  }\item[{int}]{type }\end{DoxyParamCaption})}

Computa la métrica de cercanía para un vértice, si el tipo seleccionado es 1. Si se selecciona 2, se usa la métrica harmónica alternativa. 

Definición en la línea 271 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
271                                                                                                        \{
272     pq->size = 0;
273     \textcolor{keywordtype}{double} close = 0;
274     \textcolor{keywordtype}{int} i;
275     dijkstra(g, uindex, dist, pq);
276     \textcolor{keywordflow}{for} (i = 0; i < g->size; ++i) \{
277         \textcolor{keywordflow}{if} (type == 1) \{
278             \textcolor{comment}{/* Métrica de cercanía usual */}
279             close += dist[i];
280         \}
281         \textcolor{keywordflow}{else} \{
282             \textcolor{comment}{/* Métrica harmónica para grafos disconexos */}
283             \textcolor{keywordflow}{if} (dist[i] >= DBL\_MAX || i == uindex) \textcolor{keywordflow}{continue};
284             close += 1.0 / dist[i];
285         \}
286     \}
287     \textcolor{keywordflow}{if} (type == 1) close = 1.0 / close;
288     \textcolor{keywordflow}{return} close;
289 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_a5a6317bae022cc2eb66e96d05b5981e1}\label{graphalgorithms_8c_a5a6317bae022cc2eb66e96d05b5981e1}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!compute\+Degree\+Metric@{compute\+Degree\+Metric}}
\index{compute\+Degree\+Metric@{compute\+Degree\+Metric}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{compute\+Degree\+Metric()}{computeDegreeMetric()}}
{\footnotesize\ttfamily void compute\+Degree\+Metric (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g }\end{DoxyParamCaption})}

Función redundante\+: Usada para medir el tiempo que toma evaluar la métrica de grado. 

Definición en la línea 51 del archivo graphalgorithms.\+c.



Hace referencia a graph\+Vertex\+Pointer().


\begin{DoxyCode}
51                                     \{
52     \hyperlink{structvertex}{TVertex}* v;
53     \hyperlink{structedge}{TEdge}* e;
54     \textcolor{keywordtype}{int} i;
55     \textcolor{keywordflow}{for} (i = 0; i < g->size; ++i) \{
56         v = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i);
57         v->degree = 0;
58         e = v->first;
59         \textcolor{keywordflow}{while} (e != NULL) \{
60             v->degree += e->weight;
61             e = e->next;
62         \}
63     \}
64     \textcolor{keywordflow}{return};
65 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_a9a0405fae235e46f2e982637e22a88d8}\label{graphalgorithms_8c_a9a0405fae235e46f2e982637e22a88d8}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!compute\+Page\+Rank\+Metric\+Epsilon@{compute\+Page\+Rank\+Metric\+Epsilon}}
\index{compute\+Page\+Rank\+Metric\+Epsilon@{compute\+Page\+Rank\+Metric\+Epsilon}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{compute\+Page\+Rank\+Metric\+Epsilon()}{computePageRankMetricEpsilon()}}
{\footnotesize\ttfamily int compute\+Page\+Rank\+Metric\+Epsilon (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{double}]{alpha,  }\item[{int}]{ini\+Option,  }\item[{int}]{max\+Iterations,  }\item[{double}]{eps }\end{DoxyParamCaption})}

Computa la métrica de Page\+Rank para todo el grafo, empleando un epsilon que da el criterio de convergencia. Retorna la cantidad de iteraciones tomadas. 

Definición en la línea 163 del archivo graphalgorithms.\+c.



Hace referencia a compute\+Page\+Rank\+Metric\+Vertex(), graph\+Initialize\+Page\+Rank() y graph\+Vertex\+Pointer().


\begin{DoxyCode}
163                                                                                                         \{
164     \hyperlink{graphalgorithms_8c_a58dc3553c3af88c5f7e1e6879e958341}{graphInitializePageRank}(g, iniOption);
165     \textcolor{keywordtype}{int} i, size = g->size;
166     \textcolor{keywordtype}{int} convergence = 1, it = 0;
167     \textcolor{keywordtype}{double} lastPR, newPR, maxdiff, diff;
168     \textcolor{keywordflow}{do} \{
169         convergence = 1;
170         maxdiff = 0;
171         \textcolor{keywordflow}{for} (i = 0; i < size; ++i) \{
172             lastPR = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i)->pagerank;
173             newPR = \hyperlink{graphalgorithms_8c_ac283fa06f9ce14ebbbbdc44c6dabe38d}{computePageRankMetricVertex}(g, i, alpha);
174             \textcolor{comment}{/* Si la diferencia entre los PageRanks es mayor que el epsilon, no hay convergencia aún. */}
175             diff = fabs(newPR - lastPR);
176             \textcolor{keywordflow}{if} (diff > maxdiff) maxdiff = diff;
177         \}
178         ++it;
179         \textcolor{keywordflow}{if} (maxdiff > eps) convergence = 0;
180         \textcolor{comment}{/* Para ver convergencia. */}
181         \textcolor{comment}{/* fprintf(stdout, "%d %.14lf\(\backslash\)n", it, maxdiff); */}
182     \} \textcolor{keywordflow}{while} (!convergence && it < maxIterations);
183     \textcolor{keywordflow}{return} it;
184 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_aa7498f384b25e2fa68ca828a58427c36}\label{graphalgorithms_8c_aa7498f384b25e2fa68ca828a58427c36}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!compute\+Page\+Rank\+Metric\+Iterative@{compute\+Page\+Rank\+Metric\+Iterative}}
\index{compute\+Page\+Rank\+Metric\+Iterative@{compute\+Page\+Rank\+Metric\+Iterative}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{compute\+Page\+Rank\+Metric\+Iterative()}{computePageRankMetricIterative()}}
{\footnotesize\ttfamily void compute\+Page\+Rank\+Metric\+Iterative (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{double}]{alpha,  }\item[{int}]{ini\+Option,  }\item[{int}]{iterations }\end{DoxyParamCaption})}

Computa la métrica de Page\+Rank para todo el grafo, iterando una dada cantidad de veces. 

Definición en la línea 148 del archivo graphalgorithms.\+c.



Hace referencia a compute\+Page\+Rank\+Metric\+Vertex() y graph\+Initialize\+Page\+Rank().


\begin{DoxyCode}
148                                                                                             \{
149     \hyperlink{graphalgorithms_8c_a58dc3553c3af88c5f7e1e6879e958341}{graphInitializePageRank}(g, iniOption);
150     \textcolor{keywordtype}{int} i, size = g->size;
151     \textcolor{keywordflow}{while} (iterations--) \{
152         \textcolor{keywordflow}{for} (i = 0; i < size; ++i) \{
153             \hyperlink{graphalgorithms_8c_ac283fa06f9ce14ebbbbdc44c6dabe38d}{computePageRankMetricVertex}(g, i, alpha);
154         \}
155     \}
156     \textcolor{keywordflow}{return};
157 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_ac283fa06f9ce14ebbbbdc44c6dabe38d}\label{graphalgorithms_8c_ac283fa06f9ce14ebbbbdc44c6dabe38d}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!compute\+Page\+Rank\+Metric\+Vertex@{compute\+Page\+Rank\+Metric\+Vertex}}
\index{compute\+Page\+Rank\+Metric\+Vertex@{compute\+Page\+Rank\+Metric\+Vertex}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{compute\+Page\+Rank\+Metric\+Vertex()}{computePageRankMetricVertex()}}
{\footnotesize\ttfamily double compute\+Page\+Rank\+Metric\+Vertex (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int}]{uindex,  }\item[{double}]{alpha }\end{DoxyParamCaption})}

Computa el nuevo Page\+Rank para un vértice. 

Definición en la línea 189 del archivo graphalgorithms.\+c.



Hace referencia a graph\+Vertex\+Pointer().



Referenciado por compute\+Page\+Rank\+Metric\+Epsilon() y compute\+Page\+Rank\+Metric\+Iterative().


\begin{DoxyCode}
189                                                                         \{
190     \hyperlink{structvertex}{TVertex}* u = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, uindex);
191     \hyperlink{structvertex}{TVertex}* v;
192     \hyperlink{structedge}{TEdge}* e = u->first;
193     \textcolor{keywordtype}{double} pr = 0;
194     \textcolor{keywordflow}{while} (e != NULL) \{
195         v = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, e->index);
196         pr += v->pagerank * (double)e->weight / (\textcolor{keywordtype}{double})v->degree;
197         e = e->next;
198     \}
199     pr *= alpha;
200     pr += (1 - alpha) / (\textcolor{keywordtype}{double})g->size;
201     u->pagerank = pr;
202     \textcolor{keywordflow}{return} pr;
203 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_a322c6ba75c59c6c7e5c45c809e81bb24}\label{graphalgorithms_8c_a322c6ba75c59c6c7e5c45c809e81bb24}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!get\+Closeness\+Erdos@{get\+Closeness\+Erdos}}
\index{get\+Closeness\+Erdos@{get\+Closeness\+Erdos}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{get\+Closeness\+Erdos()}{getClosenessErdos()}}
{\footnotesize\ttfamily void get\+Closeness\+Erdos (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int $\ast$}]{top }\end{DoxyParamCaption})}

Devuelve un entero que corresponde con el elemento con mayor cercanía. 

Definición en la línea 96 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
96                                             \{
97     \textcolor{keywordtype}{int} i, size = g->size;
98     \textcolor{keywordtype}{double} currpr = 0;
99     \textcolor{comment}{/* Buscamos linealmente el índice tal que la cercanía sea mayor */}
100     \hyperlink{struct_p_q}{TPriorityQueue} pq;
101     pqInitialize(&pq, MAXEDGES);
102     \hyperlink{structpair}{HeapNode} front;
103     \textcolor{keywordflow}{for} (i = 0; i < size; ++i) \{
104         currpr = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i)->closeness;
105         front.fst = -currpr;
106         front.snd = i;
107         pqPush(&pq, front);
108     \}
109     \textcolor{keywordtype}{int} tmp = 0;
110     \textcolor{keywordflow}{while} (!pqEmpty(&pq)) \{
111         front = pqTop(&pq);
112         top[tmp] = front.snd;
113         tmp++;
114     \}
115     pqClean(&pq);
116     \textcolor{keywordflow}{return};
117 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_af2b71e81e0cc7b18eb494b9bfc3f79c1}\label{graphalgorithms_8c_af2b71e81e0cc7b18eb494b9bfc3f79c1}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!get\+Degree\+Erdos@{get\+Degree\+Erdos}}
\index{get\+Degree\+Erdos@{get\+Degree\+Erdos}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{get\+Degree\+Erdos()}{getDegreeErdos()}}
{\footnotesize\ttfamily void get\+Degree\+Erdos (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int $\ast$}]{top }\end{DoxyParamCaption})}

Devuelve un entero que corresponde con el elemento con mayor grado. 

Definición en la línea 25 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
25                                          \{
26     \textcolor{keywordtype}{int} i, size = g->size, currdeg = 0;
27     \textcolor{comment}{/* Buscamos linealmente el índice tal que el grado sea mayor */}
28     \hyperlink{struct_p_q}{TPriorityQueue} pq;
29     pqInitialize(&pq, MAXSIZE);
30     \hyperlink{structpair}{HeapNode} front;
31     \textcolor{keywordflow}{for} (i = 0; i < size; ++i) \{
32         currdeg = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i)->degree;
33         front.fst = -currdeg;
34         front.snd = i;
35         pqPush(&pq, front);
36     \}
37     \textcolor{keywordtype}{int} tmp = 0;
38     \textcolor{keywordflow}{while} (!pqEmpty(&pq)) \{
39         front = pqTop(&pq);
40         top[tmp] = front.snd;
41         tmp++;
42     \}
43     pqClean(&pq);
44     \textcolor{keywordflow}{return};
45 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_a88661d3bcfaf2251248897b52deb6478}\label{graphalgorithms_8c_a88661d3bcfaf2251248897b52deb6478}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!get\+Page\+Rank\+Erdos@{get\+Page\+Rank\+Erdos}}
\index{get\+Page\+Rank\+Erdos@{get\+Page\+Rank\+Erdos}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{get\+Page\+Rank\+Erdos()}{getPageRankErdos()}}
{\footnotesize\ttfamily void get\+Page\+Rank\+Erdos (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int $\ast$}]{top }\end{DoxyParamCaption})}

Devuelve un entero que corresponde con el elemento con mayor Page\+Rank. 

Definición en la línea 70 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
70                                            \{
71     \textcolor{keywordtype}{int} i, size = g->size;
72     \textcolor{keywordtype}{double} currpr = 0;
73     \textcolor{comment}{/* Buscamos linealmente el índice tal que el PageRank sea mayor */}
74     \hyperlink{struct_p_q}{TPriorityQueue} pq;
75     pqInitialize(&pq, MAXSIZE);
76     \hyperlink{structpair}{HeapNode} front;
77     \textcolor{keywordflow}{for} (i = 0; i < size; ++i) \{
78         currpr = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i)->pagerank;
79         front.fst = -currpr;
80         front.snd = i;
81         pqPush(&pq, front);
82     \}
83     \textcolor{keywordtype}{int} tmp = 0;
84     \textcolor{keywordflow}{while} (!pqEmpty(&pq)) \{
85         front = pqTop(&pq);
86         top[tmp] = front.snd;
87         tmp++;
88     \}
89     pqClean(&pq);
90     \textcolor{keywordflow}{return};
91 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_a58dc3553c3af88c5f7e1e6879e958341}\label{graphalgorithms_8c_a58dc3553c3af88c5f7e1e6879e958341}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!graph\+Initialize\+Page\+Rank@{graph\+Initialize\+Page\+Rank}}
\index{graph\+Initialize\+Page\+Rank@{graph\+Initialize\+Page\+Rank}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{graph\+Initialize\+Page\+Rank()}{graphInitializePageRank()}}
{\footnotesize\ttfamily void graph\+Initialize\+Page\+Rank (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int}]{option }\end{DoxyParamCaption})}

Inicializa todos los vértices a un Page\+Rank por defecto, de acuerdo con la opción seleccionada.
\begin{DoxyItemize}
\item 1\+: Usando el degree.
\item 2\+: Usando closeness.
\item default\+: Usando la inversa de la cantidad de vértices. 
\end{DoxyItemize}

Definición en la línea 126 del archivo graphalgorithms.\+c.



Hace referencia a graph\+Vertex\+Pointer().



Referenciado por compute\+Page\+Rank\+Metric\+Epsilon() y compute\+Page\+Rank\+Metric\+Iterative().


\begin{DoxyCode}
126                                                     \{
127     \textcolor{keywordtype}{int} size = g->size;
128     \textcolor{keywordtype}{int} i;
129     \hyperlink{structvertex}{TVertex}* v;
130     \textcolor{keywordflow}{for} (i = 0; i < size; ++i) \{
131         v = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i);
132         \textcolor{keywordflow}{switch} (option) \{
133         \textcolor{keywordflow}{case} 1:
134             v->pagerank = (double)v->degree / g->nEdges;
135             \textcolor{keywordflow}{break};
136         \textcolor{keywordflow}{case} 2:
137             v->pagerank = (\textcolor{keywordtype}{double})v->closeness;
138         \textcolor{keywordflow}{default}:
139             v->pagerank = 1 / g->size;
140         \}
141     \}
142     \textcolor{keywordflow}{return};
143 \}
\end{DoxyCode}
\mbox{\Hypertarget{graphalgorithms_8c_a522d4e813d433f1fec5ab33a8a8913a0}\label{graphalgorithms_8c_a522d4e813d433f1fec5ab33a8a8913a0}} 
\index{graphalgorithms.\+c@{graphalgorithms.\+c}!graph\+Is\+Disconnected@{graph\+Is\+Disconnected}}
\index{graph\+Is\+Disconnected@{graph\+Is\+Disconnected}!graphalgorithms.\+c@{graphalgorithms.\+c}}
\subsubsection{\texorpdfstring{graph\+Is\+Disconnected()}{graphIsDisconnected()}}
{\footnotesize\ttfamily int graph\+Is\+Disconnected (\begin{DoxyParamCaption}\item[{\hyperlink{structgraph}{T\+Graph} $\ast$}]{g,  }\item[{int}]{ref }\end{DoxyParamCaption})}

Revisa si el grafo es disconexo. Devuelve 0 si es conexo, y n $>$ 0 si no lo es, donde n es la cantidad de vértices que no se pueden conectar con la referencia. 

Definición en la línea 297 del archivo graphalgorithms.\+c.


\begin{DoxyCode}
297                                             \{
298     \hyperlink{structqueue}{TQueue} q;
299     queueInitialize(&q);
300     \textcolor{keywordtype}{int}* visited = malloc(g->size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
301     \textcolor{keywordtype}{int} i, j;
302     visited[ref] = 1;
303     \textcolor{keywordflow}{for} (i = 0; i < g->size; ++i) \{
304         \textcolor{keywordflow}{if} (i == ref) \textcolor{keywordflow}{continue};
305         visited[i] = 0;
306     \}
307     queueInsert(&q, ref);
308     \textcolor{keywordflow}{while} (!queueIsEmpty(&q)) \{
309         i = queuePop(&q);
310         \hyperlink{structedge}{TEdge}* e = \hyperlink{graph_8c_a105b95cccbdf251ec518a845f9ed9e30}{graphVertexPointer}(g, i)->first;
311         \textcolor{keywordflow}{while} (e != NULL) \{
312             j = e->index;
313             \textcolor{keywordflow}{if} (visited[j] == 0) \{
314                 visited[j] = 1;
315                 queueInsert(&q, j);
316             \}
317             e = e->next;
318         \}
319     \}
320     queueClean(&q);
321     \textcolor{keywordtype}{int} counter = 0;
322     \textcolor{keywordflow}{for} (i = 0; i < g->size; ++i) \{
323         \textcolor{keywordflow}{if} (visited[i] == 0) \{
324             counter++;
325         \}
326     \}
327     free(visited);
328     \textcolor{keywordflow}{return} counter;
329 \}
\end{DoxyCode}
